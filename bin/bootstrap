#!/usr/bin/env bash
set -euo pipefail

TEST_MODE_ACTIVE=0
if [[ -n "${DOTFILES_TEST_MODE:-}" ]]; then
  TEST_MODE_ACTIVE=1
fi
TEST_OS="${DOTFILES_TEST_OS:-${DOTFILES_TEST_MODE:-}}"

if ((TEST_MODE_ACTIVE)) && [[ "$TEST_OS" == "macos" ]]; then
  sudo() {
    echo "Refusing to run sudo during DOTFILES_TEST_MODE (macos)" >&2
    exit 97
  }
fi

DETECTED_UNAME="${DOTFILES_FAKE_UNAME:-$(uname)}"
# shellcheck disable=SC2034
DETECTED_ARCH="${DOTFILES_FAKE_ARCH:-$(uname -m)}"

REAL_HOME="${HOME}"
SCRIPT_DIR=""
if [[ -n "${BASH_SOURCE[0]:-}" ]]; then
  SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi

REPO_DEFAULT="${REAL_HOME}/.dotfiles"
if [[ -n "$SCRIPT_DIR" ]]; then
  candidate="$(cd "${SCRIPT_DIR}/.." && pwd)"
  if [[ -d "$candidate/.git" ]]; then
    REPO_DEFAULT="$candidate"
  fi
fi

REPO_DIR="${REPO_DIR:-$REPO_DEFAULT}"
REPO_REMOTE="${DOTFILES_REMOTE:-https://github.com/x1smind/dotfiles.git}"
STOW_PKGS=()
TARGET_HOME="${DOTFILES_TARGET:-$REAL_HOME}"
DRY_RUN=0
ADOPT_EXISTING=0
REQUIRED_COMMANDS=("hostname")
ADOPT_BACKUP_ROOT=""
CONFLICT_ARCHIVE_ROOT=""
CONFLICT_TIMESTAMP=""
GIT_USER_NAME_SNAPSHOT=""
GIT_USER_EMAIL_SNAPSHOT=""
FEATURES_FROM_ENV=0
if [[ ${DOTFILES_FEATURES+set} == set ]]; then
  FEATURES_FROM_ENV=1
fi

usage() {
  cat <<'EOF'
Usage: bootstrap [--dry-run] [--target DIR] [--profile work|personal] [--adopt-existing]
  --dry-run         Log actions without mutating the system.
  --target DIR      Override DOTFILES_TARGET (defaults to $HOME).
  --profile         Pre-select DOTFILES_PROFILE without prompt.
  --adopt-existing  Move conflicting dotfiles into the repo, preserving defaults under .bootstrap-adopted.
  --no-prompt       Skip interactive wizards (non-interactive fallback).
EOF
}

NO_PROMPT=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --dry-run) DRY_RUN=1 ;;
    --target)
      [[ -n "${2:-}" ]] || {
        echo "--target requires DIR" >&2
        exit 2
      }
      TARGET_HOME="$2"
      shift
      ;;
    --profile)
      [[ -n "${2:-}" ]] || {
        echo "--profile requires a value" >&2
        exit 2
      }
      DOTFILES_PROFILE="$2"
      shift
      ;;
    --adopt-existing)
      ADOPT_EXISTING=1
      ;;
    --no-prompt)
      NO_PROMPT=1
      ;;
    -h | --help)
      usage
      exit 0
      ;;
    *)
      echo "Unknown flag: $1" >&2
      usage >&2
      exit 2
      ;;
  esac
  shift
done

log() { printf '>> %s\n' "$*"; }

SUDO_CMD=()
SUDO_LABEL=""
if ((EUID == 0)); then
  SUDO_CMD=()
  SUDO_LABEL=""
else
  if command -v sudo >/dev/null 2>&1; then
    SUDO_CMD=(sudo)
    SUDO_LABEL="sudo "
  else
    echo "sudo is required to elevate privileges. Install sudo or re-run bootstrap as root." >&2
    exit 1
  fi
fi

# Fallback package lists used before the repo is cloned. Keep in sync with linux/*-packages.txt.
DEFAULT_APT_PACKAGES=(
  git
  zsh
  stow
  curl
  wget
  tmux
  ripgrep
  fd-find
  fzf
  cmake
  build-essential
  libssl-dev
  zlib1g-dev
  libbz2-dev
  libreadline-dev
  libsqlite3-dev
  libffi-dev
  python3-pip
  python3-venv
  fontconfig
  liblzma-dev
  libyaml-dev
  unzip
)

DEFAULT_DNF_PACKAGES=(
  zsh
  stow
  curl
  wget
  tmux
  ripgrep
  fd-find
  fzf
  cmake
  @development-tools
  openssl-devel
  zlib-devel
  bzip2
  bzip2-devel
  readline-devel
  sqlite-devel
  libffi-devel
  python3-pip
  python3-virtualenv
  fontconfig
  xz-devel
  libyaml-devel
  unzip
)

NEOVIM_DESIRED_VERSION="0.11.4"

DEFAULT_FEATURE_SPEC="core,nvm,pyenv,rbenv"
declare -a DOTFILES_FEATURE_LIST=()

add_feature() {
  local name="$1"
  local existing
  for existing in "${DOTFILES_FEATURE_LIST[@]-}"; do
    if [[ "$existing" == "$name" ]]; then
      return
    fi
  done
  DOTFILES_FEATURE_LIST+=("$name")
}

set_feature_list_from_spec() {
  local spec="$1"
  DOTFILES_FEATURE_LIST=()
  if [[ -z "$spec" ]]; then
    return
  fi
  IFS=',' read -r -a _dotfiles_feature_raw <<<"$spec"
  for feature in "${_dotfiles_feature_raw[@]}"; do
    [[ -n "$feature" ]] || continue
    add_feature "$feature"
  done
  unset _dotfiles_feature_raw
}

feature_spec_from_list() {
  local IFS=','
  printf '%s' "${DOTFILES_FEATURE_LIST[*]}"
}

FEATURE_SPEC="${DOTFILES_FEATURES:-$DEFAULT_FEATURE_SPEC}"
FEATURE_SPEC="${FEATURE_SPEC//[[:space:]]/}"
if [[ "$FEATURE_SPEC" == "all" ]]; then
  FEATURE_SPEC="$DEFAULT_FEATURE_SPEC"
fi
if [[ -z "$FEATURE_SPEC" ]]; then
  FEATURE_SPEC="core"
fi
set_feature_list_from_spec "$FEATURE_SPEC"
FEATURE_SPEC="$(feature_spec_from_list)"
DOTFILES_FEATURES="$FEATURE_SPEC"
export DOTFILES_FEATURES

feature_enabled() {
  local name="$1"
  local current
  if ((${#DOTFILES_FEATURE_LIST[@]} == 0)); then
    return 1
  fi
  for current in "${DOTFILES_FEATURE_LIST[@]}"; do
    if [[ "$current" == "$name" ]]; then
      return 0
    fi
  done
  return 1
}

wizard_enabled() {
  if ((NO_PROMPT)); then
    return 1
  fi
  if ! [[ -t 0 ]]; then
    return 1
  fi
  if ((TEST_MODE_ACTIVE)); then
    return 1
  fi
  return 0
}

prompt_profile_selection() {
  local choice
  printf "\nDotfiles profile setup:\n" >&2
  printf "  [1] work\n" >&2
  printf "  [2] personal (default)\n" >&2
  read -r -p "Select profile > " choice || true
  case "${choice:-2}" in
    1) DOTFILES_PROFILE="work" ;;
    2|'') DOTFILES_PROFILE="personal" ;;
    *) DOTFILES_PROFILE="personal" ;;
  esac
}

prompt_feature_selection() {
  local modules=(nvm pyenv rbenv)
  local answer
  DOTFILES_FEATURE_LIST=("core")
  printf "\nOptional modules (Y/n):\n" >&2
  for module in "${modules[@]}"; do
    while true; do
      read -r -p "  Enable ${module}? [Y/n] " answer || true
      case "${answer:-Y}" in
        ''|Y|y)
          add_feature "$module"
          break
          ;;
        N|n)
          break
          ;;
        *)
          printf "  Please answer Y or N.\n" >&2
          ;;
      esac
    done
  done
  FEATURE_SPEC="$(feature_spec_from_list)"
  DOTFILES_FEATURES="$FEATURE_SPEC"
  export DOTFILES_FEATURES
}

maybe_run_wizard() {
  local profile_explicit=0
  if [[ ${DOTFILES_PROFILE+set} == set ]]; then
    profile_explicit=1
  fi

  if ! wizard_enabled; then
    if [[ -z "${DOTFILES_PROFILE:-}" ]]; then
      DOTFILES_PROFILE="personal"
    fi
    FEATURE_SPEC="$(feature_spec_from_list)"
    DOTFILES_FEATURES="$FEATURE_SPEC"
    export DOTFILES_FEATURES
    return
  fi

  printf "\nDotfiles bootstrap wizard\n" >&2
  printf "Press Ctrl+C any time to abort.\n\n" >&2

  if (( ! profile_explicit )); then
    prompt_profile_selection
  elif [[ -z "${DOTFILES_PROFILE:-}" ]]; then
    DOTFILES_PROFILE="personal"
  fi

  if (( ! FEATURES_FROM_ENV )); then
    prompt_feature_selection
  else
    FEATURE_SPEC="$(feature_spec_from_list)"
    DOTFILES_FEATURES="$FEATURE_SPEC"
    export DOTFILES_FEATURES
  fi
}

discover_stow_packages() {
  local pkg_root="$REPO_DIR/packages"
  STOW_PKGS=()
  if [[ ! -d "$pkg_root" ]]; then
    log "No packages directory at ${pkg_root}; skipping stow."
    return
  fi
  while IFS= read -r pkg; do
    [[ -n "$pkg" ]] && STOW_PKGS+=("$pkg")
  done < <(find "$pkg_root" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | LC_ALL=C sort -u)
  if ((${#STOW_PKGS[@]} == 0)); then
    log "No stow packages discovered under ${pkg_root}; skipping stow."
  fi
}

assert_safe_path() {
  local path="$1"
  if ((TEST_MODE_ACTIVE)) && [[ "$TEST_OS" == "macos" ]]; then
    case "$path" in
      /etc | /etc/*)
        echo "Refusing to modify $path under DOTFILES_TEST_MODE (macos)" >&2
        exit 98
        ;;
    esac
  fi
}

sanity_checks() {
  local missing=()
  local cmd
  for cmd in "${REQUIRED_COMMANDS[@]}"; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      missing+=("$cmd")
    fi
  done
  if ((${#missing[@]})); then
    printf 'Missing required command(s): %s\n' "${missing[*]}" >&2
    printf 'Install the missing command(s) and re-run bootstrap.\n' >&2
    exit 1
  fi
}

append_unique_line() {
  local file="$1"
  local line="$2"
  assert_safe_path "$file"
  if ((DRY_RUN)); then
    log "[dry-run] append '${line}' -> ${file}"
    return 0
  fi
  mkdir -p "$(dirname "$file")"
  touch "$file"
  grep -qxF "$line" "$file" || printf '%s\n' "$line" >>"$file"
}

ensure_dir() {
  assert_safe_path "$1"
  if ((DRY_RUN)); then
    log "[dry-run] mkdir -p $1"
    return 0
  fi
  mkdir -p "$1"
}

ensure_conflict_timestamp() {
  if [[ -n "$CONFLICT_TIMESTAMP" ]]; then
    return
  fi
  if ((DRY_RUN)); then
    CONFLICT_TIMESTAMP="dry-run"
  else
    CONFLICT_TIMESTAMP="$(date +%Y%m%dT%H%M%S)"
  fi
}

ensure_conflict_archive_root() {
  if [[ -n "$CONFLICT_ARCHIVE_ROOT" ]]; then
    return
  fi
  ensure_conflict_timestamp
  CONFLICT_ARCHIVE_ROOT="$REPO_DIR/.bootstrap-backups/$CONFLICT_TIMESTAMP"
  ensure_dir "$CONFLICT_ARCHIVE_ROOT"
}

ensure_adopt_backup_root() {
  if [[ -n "$ADOPT_BACKUP_ROOT" ]]; then
    return
  fi
  ensure_conflict_timestamp
  ADOPT_BACKUP_ROOT="$REPO_DIR/.bootstrap-adopted-defaults/$CONFLICT_TIMESTAMP"
  ensure_dir "$ADOPT_BACKUP_ROOT"
}

next_available_path() {
  local base="$1"
  local candidate="$base"
  local suffix=0
  while [[ -e "$candidate" || -L "$candidate" ]]; do
    candidate="${base}.${suffix}"
    ((suffix++))
  done
  printf '%s\n' "$candidate"
}

archive_conflict_path() {
  local target="$1"
  local rel="$2"
  assert_safe_path "$target"
  if [[ ! -e "$target" && ! -L "$target" ]]; then
    return
  fi
  ensure_conflict_archive_root
  local relpath="$rel"
  if [[ -z "$relpath" || "$relpath" == "$target" ]]; then
    relpath="${target#"$HOME"/}"
    if [[ "$relpath" == "$target" || -z "$relpath" ]]; then
      relpath="$(basename "$target")"
    fi
  fi
  relpath="${relpath#/}"
  local dest_base="${CONFLICT_ARCHIVE_ROOT}/${relpath}"
  if ((DRY_RUN)); then
    log "[dry-run] move ${target} -> ${dest_base}"
    return
  fi
  ensure_dir "$(dirname "$dest_base")"
  local dest
  dest="$(next_available_path "$dest_base")"
  ensure_dir "$(dirname "$dest")"
  mv "$target" "$dest"
  log "Archived existing dotfile ${target} -> ${dest}"
}

adopt_conflict_path() {
  local target="$1"
  local pkg="$2"
  local rel="$3"
  local src="$REPO_DIR/packages/$pkg/$rel"
  if [[ -z "$rel" ]]; then
    rel="$(basename "$target")"
    src="$REPO_DIR/packages/$pkg/$rel"
  fi
  if ((DRY_RUN)); then
    log "[dry-run] adopt ${target} -> ${src}"
    return
  fi
  if [[ -d "$src" && ! -L "$src" ]]; then
    log "Package entry packages/${pkg}/${rel} is a directory; archiving ${target} instead of adopting."
    archive_conflict_path "$target" "$rel"
    return
  fi
  ensure_dir "$(dirname "$src")"
  if [[ -e "$src" || -L "$src" ]]; then
    ensure_adopt_backup_root
    local backup_base="${ADOPT_BACKUP_ROOT}/${pkg}/${rel}"
    ensure_dir "$(dirname "$backup_base")"
    local backup_dest
    backup_dest="$(next_available_path "$backup_base")"
    ensure_dir "$(dirname "$backup_dest")"
    mv "$src" "$backup_dest"
    log "Saved existing package entry packages/${pkg}/${rel} -> ${backup_dest}"
  fi
  mv "$target" "$src"
  log "Adopted existing dotfile ${target} -> packages/${pkg}/${rel}"
}

trim_leading_whitespace() {
  local str="$1"
  str="${str#"${str%%[![:space:]]*}"}"
  printf '%s' "$str"
}

backup_conflict_path() {
  local target="$1"
  local pkg="${2:-}"
  local rel="${3:-}"
  assert_safe_path "$target"
  if [[ ! -e "$target" && ! -L "$target" ]]; then
    return
  fi
  if ((ADOPT_EXISTING)) && [[ -n "$pkg" ]]; then
    adopt_conflict_path "$target" "$pkg" "$rel"
    return
  fi
  archive_conflict_path "$target" "$rel"
}

capture_git_identity() {
  if ! command -v git >/dev/null 2>&1; then
    return
  fi
  GIT_USER_NAME_SNAPSHOT="$(git config --global user.name 2>/dev/null || true)"
  GIT_USER_EMAIL_SNAPSHOT="$(git config --global user.email 2>/dev/null || true)"
}

restore_git_identity() {
  if ! command -v git >/dev/null 2>&1; then
    return
  fi
  if [[ -z "$GIT_USER_NAME_SNAPSHOT" && -z "$GIT_USER_EMAIL_SNAPSHOT" ]]; then
    return
  fi
  if ((DRY_RUN)); then
    log "[dry-run] Restore git identity (user.name='${GIT_USER_NAME_SNAPSHOT:-}' user.email='${GIT_USER_EMAIL_SNAPSHOT:-}')"
    return
  fi
  if [[ -n "$GIT_USER_NAME_SNAPSHOT" ]]; then
    git config --global user.name "$GIT_USER_NAME_SNAPSHOT"
  fi
  if [[ -n "$GIT_USER_EMAIL_SNAPSHOT" ]]; then
    git config --global user.email "$GIT_USER_EMAIL_SNAPSHOT"
  fi
}

detect_os() {
  if [[ "$DETECTED_UNAME" == "Darwin" ]]; then
    echo "macos"
    return
  fi
  if [[ -f /etc/os-release ]]; then
    # shellcheck disable=SC1091
    . /etc/os-release
    if [[ "$ID" == "fedora" || "$ID_LIKE" == *fedora* || "$ID_LIKE" == *rhel* ]]; then
      echo "fedora"
      return
    fi
    if [[ "$ID" == "ubuntu" || "$ID_LIKE" == *debian* ]]; then
      echo "debian"
      return
    fi
  fi
  echo "unknown"
}

detect_brew_bin() {
  if [[ -n "${DOTFILES_BREW_BIN:-}" && -x "${DOTFILES_BREW_BIN}" ]]; then
    printf '%s\n' "${DOTFILES_BREW_BIN}"
    return 0
  fi
  if command -v brew >/dev/null 2>&1; then
    command -v brew
    return 0
  fi
  if ((TEST_MODE_ACTIVE)) && [[ "$TEST_OS" == "macos" ]]; then
    return 1
  fi
  if [[ -x /opt/homebrew/bin/brew ]]; then
    printf '%s\n' "/opt/homebrew/bin/brew"
    return 0
  fi
  if [[ -x /usr/local/bin/brew ]]; then
    printf '%s\n' "/usr/local/bin/brew"
    return 0
  fi
  return 1
}

install_homebrew() {
  if [[ -n "${DOTFILES_BREW_INSTALLER:-}" ]]; then
    if ((DRY_RUN)); then
      log "[dry-run] Invoke custom Homebrew installer: ${DOTFILES_BREW_INSTALLER}"
      return 0
    fi
    "${DOTFILES_BREW_INSTALLER}"
    return
  fi
  if ((DRY_RUN)); then
    log "[dry-run] Install Homebrew via official script"
    return
  fi
  NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
}

ensure_brew_shellenv_line() {
  local brew_bin="$1"
  local dest="${2:-$TARGET_HOME/.zprofile}"
  local line
  # shellcheck disable=SC2016  # keep $(brew shellenv) literal for insertion into profile
  line=$(printf 'eval "$(%q shellenv)"' "$brew_bin")
  if ((DRY_RUN)); then
    log "[dry-run] ensure ${dest} exports Homebrew shellenv via ${brew_bin}"
    return
  fi
  assert_safe_path "$dest"
  mkdir -p "$(dirname "$dest")"
  touch "$dest"
  local tmp
  tmp="$(mktemp "${dest}.XXXXXX")"
  awk -v line="$line" '
    /brew shellenv/ {next}
    {print}
    END {print line}
  ' "$dest" >"$tmp"
  mv "$tmp" "$dest"
}

_brew_preflight() {
  local brew_bin="${1:-}"
  [[ -n "$brew_bin" ]] || return 0

  local log_prefix=""
  if ((DRY_RUN)); then
    log_prefix="[dry-run] "
    log "${log_prefix}${brew_bin} update --quiet"
  elif ((TEST_MODE_ACTIVE)); then
    log_prefix="[test] "
    log "${log_prefix}${brew_bin} update --quiet"
    "${brew_bin}" update --quiet >/dev/null 2>&1
  else
    "${brew_bin}" update --quiet >/dev/null 2>&1
  fi

  local tap_list
  tap_list="$("${brew_bin}" tap 2>/dev/null || true)"
  if grep -qx 'homebrew/cask-fonts' <<<"$tap_list"; then
    if ((DRY_RUN)); then
      log "${log_prefix}${brew_bin} untap homebrew/cask-fonts"
      return 0
    fi
    if ((TEST_MODE_ACTIVE)); then
      log "${log_prefix}${brew_bin} untap homebrew/cask-fonts"
    else
      log "Untapping deprecated homebrew/cask-fonts tap"
    fi
    if ! "${brew_bin}" untap homebrew/cask-fonts >/dev/null 2>&1; then
      log "Failed to untap homebrew/cask-fonts (continuing)"
    fi
  fi
}

install_prereqs_macos() {
  local brewfile="${REPO_DIR}/macos/Brewfile"
  if ((DRY_RUN)); then
    log "[dry-run] Verify Xcode Command Line Tools presence"
    if detect_brew_bin >/dev/null 2>&1; then
      local brew_bin
      brew_bin="$(detect_brew_bin)"
      log "[dry-run] Homebrew detected at ${brew_bin}"
      log "[dry-run] ensure ${TARGET_HOME}/.zprofile contains eval for ${brew_bin}"
      log "[dry-run] ${brew_bin} update --quiet"
      log "[dry-run] ${brew_bin} untap homebrew/cask-fonts (if present)"
    else
      log "[dry-run] Install Homebrew via official script"
    fi
    log "[dry-run] brew bundle --file ${brewfile}"
    return
  fi
  if ! xcode-select -p >/dev/null 2>&1; then
    xcode-select --install || true
  fi
  if ! detect_brew_bin >/dev/null 2>&1; then
    install_homebrew
  fi
  local brew_bin
  if ! brew_bin="$(detect_brew_bin)"; then
    echo "Homebrew is required but could not be located after installation." >&2
    exit 1
  fi
  eval "$("$brew_bin" shellenv)"
  ensure_brew_shellenv_line "$brew_bin" "$TARGET_HOME/.zprofile"
  _brew_preflight "$brew_bin"
  if ! "$brew_bin" bundle --file "$brewfile"; then
    local brew_prefix
    brew_prefix="$("$brew_bin" --prefix)"
    if [[ -d "$brew_prefix/var/homebrew" && ! -w "$brew_prefix/var/homebrew" ]]; then
      echo "Homebrew directory $brew_prefix/var/homebrew is not writable by $(whoami)." >&2
      echo "Adjust permissions then re-run bootstrap. Example:" >&2
      echo "  sudo chown -R $(whoami):admin '$brew_prefix/var/homebrew'" >&2
      echo "  sudo chmod -R g+rw '$brew_prefix/var/homebrew'" >&2
    fi
    return 1
  fi
}

install_prereqs_debian() {
  local package_file="$REPO_DIR/linux/apt-packages.txt"
  local packages=()
  if [[ -f "$package_file" ]]; then
    mapfile -t packages < <(grep -vE '^\s*(#|$)' "$package_file")
  fi
  if ((${#packages[@]} == 0)); then
    packages=("${DEFAULT_APT_PACKAGES[@]}")
  fi

  if ((DRY_RUN)); then
    log "[dry-run] ${SUDO_LABEL}apt-get update -y"
    log "[dry-run] ${SUDO_LABEL}apt-get install -y ${packages[*]}"
    log "[dry-run] Handle fd alternative if needed"
    return
  fi
  "${SUDO_CMD[@]}" apt-get update -y
  "${SUDO_CMD[@]}" apt-get install -y "${packages[@]}"
  if ! command -v fd >/dev/null 2>&1 && command -v fdfind >/dev/null 2>&1; then
    "${SUDO_CMD[@]}" update-alternatives --install /usr/local/bin/fd fd "$(command -v fdfind)" 10
  fi
}

install_prereqs_fedora() {
  local package_file="$REPO_DIR/linux/dnf-packages.txt"
  local packages=()
  if [[ -f "$package_file" ]]; then
    mapfile -t packages < <(grep -vE '^\s*(#|$)' "$package_file")
  fi
  if ((${#packages[@]} == 0)); then
    packages=("${DEFAULT_DNF_PACKAGES[@]}")
  fi

  if ((DRY_RUN)); then
    log "[dry-run] ${SUDO_LABEL}dnf makecache"
    log "[dry-run] ${SUDO_LABEL}dnf install -y ${packages[*]}"
    return
  fi
  "${SUDO_CMD[@]}" dnf makecache
  "${SUDO_CMD[@]}" dnf install -y "${packages[@]}"
}

current_nvim_version() {
  if ! command -v nvim >/dev/null 2>&1; then
    return 1
  fi
  nvim --version | head -n1 | awk '{print $2}'
}

install_neovim_tarball() {
  local url="$1"
  local desired="$2"
  local install_root="$3"
  local bin_path="$4"

  local install_dir="${install_root}/${desired}"
  if command -v nvim >/dev/null 2>&1; then
    local current
    current="$(current_nvim_version)"
    if [[ "$current" == "$desired" ]]; then
      return 0
    fi
  fi

  if ((DRY_RUN)); then
    log "[dry-run] Install Neovim ${desired} from ${url} under ${install_dir} and symlink ${bin_path}"
    return 0
  fi

  local tmp
  tmp="$(mktemp -d)"
  local archive="${tmp}/nvim.tar.gz"
  if ! curl -fsSL "$url" -o "$archive"; then
    echo "Failed to download Neovim ${desired} from ${url}" >&2
    rm -rf "$tmp"
    return 1
  fi
  if ! tar -xzf "$archive" -C "$tmp"; then
    echo "Failed to extract Neovim archive ${archive}" >&2
    rm -rf "$tmp"
    return 1
  fi
  local extracted_dir
  extracted_dir="$(find "$tmp" -mindepth 1 -maxdepth 1 -type d -name 'nvim-*' -print -quit)"
  if [[ -z "$extracted_dir" ]]; then
    echo "Could not locate extracted Neovim directory in ${tmp}" >&2
    rm -rf "$tmp"
    return 1
  fi

  "${SUDO_CMD[@]}" rm -rf "$install_dir"
  "${SUDO_CMD[@]}" mkdir -p "$install_root"
  "${SUDO_CMD[@]}" mv "$extracted_dir" "$install_dir"
  "${SUDO_CMD[@]}" ln -sfn "${install_dir}/bin/nvim" "$bin_path"

  rm -rf "$tmp"
  log "Installed Neovim ${desired} -> ${bin_path}"
}

ensure_neovim_linux() {
  local desired="$NEOVIM_DESIRED_VERSION"
  local desired_tag="v${desired}"
  local tarball=""
  case "$DETECTED_ARCH" in
    x86_64 | amd64)
      tarball="nvim-linux-x86_64.tar.gz"
      ;;
    arm64 | aarch64)
      tarball="nvim-linux-arm64.tar.gz"
      ;;
    *)
      log "Skipping Neovim install: unsupported Linux architecture ${DETECTED_ARCH}"
      return 0
      ;;
  esac
  local url="https://github.com/neovim/neovim/releases/download/${desired_tag}/${tarball}"
  install_neovim_tarball "$url" "$desired" "/usr/local/neovim" "/usr/local/bin/nvim"
}

ensure_neovim_macos() {
  local desired="$NEOVIM_DESIRED_VERSION"
  local desired_tag="v${desired}"
  local tarball=""
  case "$DETECTED_ARCH" in
    arm64)
      tarball="nvim-macos-arm64.tar.gz"
      ;;
    x86_64)
      tarball="nvim-macos-x86_64.tar.gz"
      ;;
    *)
      log "Skipping Neovim install: unsupported macOS architecture ${DETECTED_ARCH}"
      return 0
      ;;
  esac
  local url="https://github.com/neovim/neovim/releases/download/${desired_tag}/${tarball}"
  install_neovim_tarball "$url" "$desired" "/usr/local/neovim" "/usr/local/bin/nvim"
}

ensure_neovim() {
  local os="$1"
  case "$os" in
    debian | fedora)
      ensure_neovim_linux
      ;;
    macos)
      ensure_neovim_macos
      ;;
  esac
}

install_ohmyzsh() {
  if ((DRY_RUN)); then
    log "[dry-run] Install Oh My Zsh into $HOME/.oh-my-zsh"
    return
  fi
  if [[ ! -d "$HOME/.oh-my-zsh" ]]; then
    RUNZSH=no CHSH=no KEEP_ZSHRC=yes \
      sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
  fi
}

install_powerlevel10k() {
  local theme_dir="${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k"
  if ((DRY_RUN)); then
    log "[dry-run] Ensure powerlevel10k exists at $theme_dir"
    return
  fi
  [[ -d "$theme_dir" ]] || git clone --depth=1 https://github.com/romkatv/powerlevel10k.git "$theme_dir"
}

install_fonts() {
  if ((DRY_RUN)); then
    log "[dry-run] Install Hack & Meslo Nerd fonts (macOS via brew cask, Linux via ~/.local/share/fonts)"
    log "[dry-run] Cache font archives under ${HOME}/.cache/dotfiles/fonts when present"
    return
  fi
  echo "Installing Hack Nerd Font (primary) and Meslo Nerd (secondary fallback)..."
  if [[ "$DETECTED_UNAME" == "Darwin" ]]; then
    local brew_bin
    if ! brew_bin="$(detect_brew_bin)"; then
      echo "Homebrew not available; skipping macOS font install." >&2
      return
    fi
    local font
    for font in font-hack-nerd-font font-meslo-lg-nerd-font; do
      if "$brew_bin" list --cask "$font" >/dev/null 2>&1; then
        echo "Font ${font} already installed (via brew)."
      else
        "$brew_bin" install --cask "$font"
      fi
    done
  else
    if ! command -v unzip >/dev/null 2>&1; then
      echo "unzip not available; skipping font install." >&2
      return
    fi
    local font_dir="$HOME/.local/share/fonts"
    local cache_root="${XDG_CACHE_HOME:-$HOME/.cache}"
    local cache_dir="${cache_root}/dotfiles/fonts"
    ensure_dir "$cache_dir"
    ensure_dir "$font_dir"

    local refreshed=0
    local name url zip_path
    while IFS=":" read -r name url; do
      [[ -z "$name" || -z "$url" ]] && continue
      zip_path="${cache_dir}/${name}.zip"
      if [[ -f "$zip_path" ]]; then
        log "Using cached archive for ${name} Nerd Font"
      else
        log "Downloading ${name} Nerd Font archive"
        if ! curl -fsSL "$url" -o "$zip_path"; then
          echo "Failed to download ${name} Nerd Font from ${url}; skipping." >&2
          rm -f "$zip_path"
          continue
        fi
      fi
      if unzip -oq "$zip_path" -d "$font_dir"; then
        refreshed=1
      else
        echo "Failed to extract ${zip_path}; removing cache entry." >&2
        rm -f "$zip_path"
      fi
    done <<'EOF'
Hack:https://github.com/ryanoasis/nerd-fonts/releases/latest/download/Hack.zip
Meslo:https://github.com/ryanoasis/nerd-fonts/releases/latest/download/Meslo.zip
EOF
    if ((refreshed)); then
      if command -v fc-cache >/dev/null 2>&1; then
        fc-cache -f "$font_dir" >/dev/null
      else
        log "fc-cache not found; skipped font cache refresh"
      fi
    fi
  fi
}

install_nvm() {
  if ((DRY_RUN)); then
    log "[dry-run] Install nvm under $HOME/.nvm, ensure LTS default, and enable corepack"
    return
  fi
  if [[ ! -d "$HOME/.nvm" ]]; then
    (
      export PROFILE=/dev/null
      curl -fsSL https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
    )
  fi
  # shellcheck disable=SC1090,SC1091
  [[ -s "$HOME/.nvm/nvm.sh" ]] && . "$HOME/.nvm/nvm.sh"
  nvm install --lts >/dev/null 2>&1 || true
  nvm alias default 'lts/*'
  nvm use default >/dev/null 2>&1 || nvm use --lts >/dev/null 2>&1 || true
  if command -v corepack >/dev/null 2>&1; then
    corepack enable >/dev/null 2>&1 || true
  fi
}

install_pyenv() {
  if ((DRY_RUN)); then
    if command -v pyenv >/dev/null 2>&1 || [[ -d "$HOME/.pyenv" ]]; then
      log "[dry-run] pyenv already present; ensure 3.12.6 installed"
    else
      log "[dry-run] Install pyenv under $HOME/.pyenv and set 3.12.6 as global"
    fi
    return
  fi
  if ! command -v pyenv >/dev/null 2>&1; then
    if [[ -d "$HOME/.pyenv" ]]; then
      log "Detected existing $HOME/.pyenv; reusing without reinstall."
    else
      curl -fsSL https://pyenv.run | bash
    fi
  fi
  export PYENV_ROOT="$HOME/.pyenv"
  export PATH="$PYENV_ROOT/bin:$PATH"
  eval "$(pyenv init -)"
  pyenv install -s 3.12.6
  pyenv global 3.12.6
}

install_rbenv() {
  if ((DRY_RUN)); then
    if command -v rbenv >/dev/null 2>&1 || [[ -d "$HOME/.rbenv" ]]; then
      log "[dry-run] rbenv already present; ensure 3.3.5 installed"
    else
      log "[dry-run] Install rbenv under $HOME/.rbenv and set 3.3.5 as global"
    fi
    return
  fi
  if ! command -v rbenv >/dev/null 2>&1; then
    if [[ -d "$HOME/.rbenv" ]]; then
      log "Detected existing $HOME/.rbenv; reusing without reinstall."
    else
      git clone https://github.com/rbenv/rbenv.git "$HOME/.rbenv"
      git clone https://github.com/rbenv/ruby-build.git "$HOME/.rbenv/plugins/ruby-build"
    fi
  elif [[ ! -d "$HOME/.rbenv" ]]; then
    mkdir -p "$HOME/.rbenv"
  fi
  export PATH="$HOME/.rbenv/bin:$PATH"
  eval "$(rbenv init -)"
  rbenv install -s 3.3.5
  rbenv global 3.3.5
}

install_tpm() {
  local tpm_dir="$HOME/.tmux/plugins/tpm"
  if ((DRY_RUN)); then
    log "[dry-run] Ensure TPM exists at $tpm_dir"
    return
  fi
  if [[ ! -d "$tpm_dir" ]]; then
    git clone https://github.com/tmux-plugins/tpm "$tpm_dir"
  fi
}

ensure_stow() {
  local os="$1"
  if command -v stow >/dev/null 2>&1; then
    return
  fi
  case "$os" in
    macos)
      if ((DRY_RUN)); then
        log "[dry-run] Ensure GNU Stow via: brew install stow"
        return
      else
        log "Installing GNU Stow via Homebrew"
        brew install stow
      fi
      ;;
    debian)
      if ((DRY_RUN)); then
        log "[dry-run] Ensure GNU Stow via: ${SUDO_LABEL}apt-get install -y stow"
        return
      else
        log "Installing GNU Stow via apt-get"
        "${SUDO_CMD[@]}" apt-get install -y stow
      fi
      ;;
    fedora)
      if ((DRY_RUN)); then
        log "[dry-run] Ensure GNU Stow via: ${SUDO_LABEL}dnf install -y stow"
        return
      else
        log "Installing GNU Stow via dnf"
        "${SUDO_CMD[@]}" dnf install -y stow
      fi
      ;;
    *)
      echo "GNU Stow is required but automatic installation is unsupported for OS: $os" >&2
      exit 1
      ;;
  esac
}

stow_dotfiles() {
  if ((${#STOW_PKGS[@]} == 0)); then
    return
  fi
  ensure_dir "$HOME"
  if ! command -v stow >/dev/null 2>&1; then
    if ((DRY_RUN)); then
      log "[dry-run] Skip stow linking (GNU Stow not available)"
      return
    fi
    echo "GNU Stow is required but was not installed successfully." >&2
    exit 1
  fi
  pushd "$REPO_DIR/packages" >/dev/null
  for pkg in "${STOW_PKGS[@]}"; do
    if ((DRY_RUN)); then
      log "[dry-run] stow -n --target \"$HOME\" \"$pkg\""
      stow -n --target "$HOME" "$pkg"
    else
      local stow_output
      if stow_output="$(stow -n --target "$HOME" "$pkg" 2>&1)"; then
        stow --target "$HOME" -R "$pkg"
      else
        local cleaned=0
        while IFS= read -r line; do
          if [[ "$line" == *"existing target is not a link:"* || "$line" == *"existing target is neither a link nor a directory:"* ]]; then
            cleaned=1
            local target="${line##*: }"
            target="$(trim_leading_whitespace "$target")"
            target="${target#./}"
            if [[ "$target" != /* ]]; then
              target="$HOME/$target"
            fi
            local relpath=""
            if [[ "$target" == "$HOME" ]]; then
              relpath=""
            elif [[ "$target" == "$HOME/"* ]]; then
              relpath="${target#"$HOME"/}"
            fi
            backup_conflict_path "$target" "$pkg" "$relpath"
          elif [[ "$line" == *"cannot stow"* && "$line" == *"over existing target"* ]]; then
            cleaned=1
            local target_part="${line#*over existing target }"
            target_part="${target_part%% since*}"
            local target
            target="$(trim_leading_whitespace "$target_part")"
            target="${target#./}"
            if [[ "$target" != /* ]]; then
              target="$HOME/$target"
            fi
            local relpath=""
            if [[ "$target" == "$HOME" ]]; then
              relpath=""
            elif [[ "$target" == "$HOME/"* ]]; then
              relpath="${target#"$HOME"/}"
            fi
            backup_conflict_path "$target" "$pkg" "$relpath"
          else
            printf '%s\n' "$line" >&2
          fi
        done <<<"$stow_output"
        if ((cleaned)); then
          stow --target "$HOME" -R "$pkg"
        else
          printf '%s\n' "$stow_output" >&2
          exit 1
        fi
      fi
    fi
  done
  popd >/dev/null
}

select_profile() {
  if [[ -z "${DOTFILES_PROFILE:-}" ]]; then
    DOTFILES_PROFILE="personal"
  fi
  export DOTFILES_PROFILE
  local f="$REPO_DIR/profiles/${DOTFILES_PROFILE}/zshrc.profile.zsh"
  if [[ -r "$f" ]]; then
    if ((DRY_RUN)); then
      log "[dry-run] Source profile $f and append loader to $HOME/.zshrc.local"
    else
      if ((TEST_MODE_ACTIVE)); then
        log "[test-mode] Skip sourcing profile $f"
      else
        # shellcheck disable=SC1090
        source "$f"
      fi
      append_unique_line "$HOME/.zshrc.local" "source \"$f\""
    fi
  fi
}

apply_host_overrides() {
  local hn
  hn="$(hostname)"
  local z="$REPO_DIR/hosts/${hn}/zshrc.host.zsh"
  if [[ -r "$z" ]]; then
    if ((DRY_RUN)); then
      log "[dry-run] Source host override $z and append loader to $HOME/.zshrc.local"
    else
      if ((TEST_MODE_ACTIVE)); then
        log "[test-mode] Skip sourcing host override $z"
      else
        # shellcheck disable=SC1090
        source "$z"
      fi
      append_unique_line "$HOME/.zshrc.local" "source \"$z\""
    fi
  fi
  local g="$REPO_DIR/hosts/${hn}/gitconfig.host"
  if [[ -r "$g" ]]; then
    if ((DRY_RUN)); then
      log "[dry-run] Copy $g -> $HOME/.gitconfig.local"
    else
      cp -f "$g" "$HOME/.gitconfig.local"
    fi
  fi
}

switch_default_shell() {
  local zsh_path
  if ! zsh_path="$(command -v zsh 2>/dev/null)"; then
    log "zsh not found; skipping default shell update"
    return
  fi

  if [[ "$SHELL" == "$zsh_path" ]]; then
    return
  fi

  if ((DRY_RUN)); then
    log "[dry-run] chsh -s ${zsh_path}"
    log "[dry-run] After changing shells, run 'exec zsh' or reopen your terminal."
    return
  fi

  if chsh -s "$zsh_path"; then
    log "Default shell updated to ${zsh_path}. Run 'exec zsh' or open a new terminal to start using it."
  else
    log "Unable to change default shell automatically. Run 'chsh -s ${zsh_path}' manually or 'exec ${zsh_path}' for this session."
  fi
}

ensure_git_bootstrap() {
  local os="$1"
  if command -v git >/dev/null 2>&1; then
    return
  fi

  case "$os" in
    debian)
      if ((DRY_RUN)); then
        log "[dry-run] ${SUDO_LABEL}apt-get update -y (ensure git)"
        log "[dry-run] ${SUDO_LABEL}apt-get install -y git"
        return
      fi
      "${SUDO_CMD[@]}" apt-get update -y
      "${SUDO_CMD[@]}" apt-get install -y git
      ;;
    fedora)
      if ((DRY_RUN)); then
        log "[dry-run] ${SUDO_LABEL}dnf makecache (ensure git)"
        log "[dry-run] ${SUDO_LABEL}dnf install -y git"
        return
      fi
      "${SUDO_CMD[@]}" dnf makecache
      "${SUDO_CMD[@]}" dnf install -y git
      ;;
    macos)
      if ! xcode-select -p >/dev/null 2>&1; then
        echo "Xcode Command Line Tools not detected. Launching installer..." >&2
        xcode-select --install || true
      fi
      echo "git is required to clone the dotfiles repository. Once the Xcode Command Line Tools are installed, re-run bootstrap." >&2
      exit 1
      ;;
    *)
      echo "git not found and automatic installation unsupported for OS: $os" >&2
      exit 1
      ;;
  esac
}

main() {
  OS=$(detect_os)

  capture_git_identity

  ensure_git_bootstrap "$OS"

  if [[ ! -d "$REPO_DIR/.git" ]]; then
    if ((DRY_RUN)); then
      log "[dry-run] Clone dotfiles repo into $REPO_DIR"
    else
      ensure_dir "$(dirname "$REPO_DIR")"
      if ! git clone "$REPO_REMOTE" "$REPO_DIR"; then
        echo "Failed to clone dotfiles repository from ${REPO_REMOTE}" >&2
        exit 1
      fi
    fi
  fi

  if [[ -z "${DOTFILES_ROOT:-}" ]]; then
    export DOTFILES_ROOT="$REPO_DIR"
  fi

  maybe_run_wizard

  case "$OS" in
    macos) install_prereqs_macos ;;
    debian) install_prereqs_debian ;;
    fedora) install_prereqs_fedora ;;
    *)
      echo "Unsupported OS: $OS" >&2
      exit 1
      ;;
  esac

  ensure_neovim "$OS"

  sanity_checks

  local previous_home="$HOME"
  export HOME="$TARGET_HOME"

  install_ohmyzsh
  install_powerlevel10k
  install_fonts
  discover_stow_packages
  if ((${#STOW_PKGS[@]} > 0)); then
    ensure_stow "$OS"
    stow_dotfiles
  fi
  install_tpm
  if feature_enabled "nvm"; then
    install_nvm
  else
    log "Skipping nvm install (feature disabled)"
  fi
  if feature_enabled "pyenv"; then
    install_pyenv
  else
    log "Skipping pyenv install (feature disabled)"
  fi
  if feature_enabled "rbenv"; then
    install_rbenv
  else
    log "Skipping rbenv install (feature disabled)"
  fi
  select_profile
  apply_host_overrides
  restore_git_identity
  log "Enabled features: ${FEATURE_SPEC}"

  switch_default_shell

  export HOME="$previous_home"

  if ((DRY_RUN)); then
    printf "\n✅ Dry run complete. No changes were made.\n"
  else
    printf "\n✅ Done. Run 'exec zsh' or open a new terminal to load the new shell.\n"
    echo "Set your terminal font to 'Hack Nerd Font' (primary) or 'MesloLGS Nerd Font' (fallback)."
    echo "Run 'tmux' then prefix + I to install tmux plugins."
    echo "Optionally run: ~/.dotfiles/bin/keys-setup"
  fi
}

if [[ -z "${BASH_SOURCE[0]:-}" || "${BASH_SOURCE[0]}" == "$0" ]]; then
  main "$@"
fi
