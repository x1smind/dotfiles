#!/usr/bin/env bash
set -euo pipefail

TEST_MODE_ACTIVE=0
if [[ -n "${DOTFILES_TEST_MODE:-}" ]]; then
  TEST_MODE_ACTIVE=1
fi
TEST_OS="${DOTFILES_TEST_OS:-${DOTFILES_TEST_MODE:-}}"

if (( TEST_MODE_ACTIVE )) && [[ "$TEST_OS" == "macos" ]]; then
  sudo() {
    echo "Refusing to run sudo during DOTFILES_TEST_MODE (macos)" >&2
    exit 97
  }
fi

DETECTED_UNAME="${DOTFILES_FAKE_UNAME:-$(uname)}"
# shellcheck disable=SC2034
DETECTED_ARCH="${DOTFILES_FAKE_ARCH:-$(uname -m)}"

REAL_HOME="${HOME}"
SCRIPT_DIR=""
if [[ -n "${BASH_SOURCE[0]:-}" ]]; then
  SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi

REPO_DEFAULT="${REAL_HOME}/.dotfiles"
if [[ -n "$SCRIPT_DIR" ]]; then
  candidate="$(cd "${SCRIPT_DIR}/.." && pwd)"
  if [[ -d "$candidate/.git" ]]; then
    REPO_DEFAULT="$candidate"
  fi
fi

REPO_DIR="${REPO_DIR:-$REPO_DEFAULT}"
STOW_PKGS=("git" "zsh" "tmux" "nvim" "vim")
TARGET_HOME="${DOTFILES_TARGET:-$REAL_HOME}"
DRY_RUN=0
REQUIRED_COMMANDS=("hostname")

usage() {
  cat <<'EOF'
Usage: bootstrap [--dry-run] [--target DIR] [--profile work|personal]
  --dry-run     Log actions without mutating the system.
  --target DIR  Override DOTFILES_TARGET (defaults to $HOME).
  --profile     Pre-select DOTFILES_PROFILE without prompt.
EOF
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --dry-run) DRY_RUN=1 ;;
    --target)
      [[ -n "${2:-}" ]] || { echo "--target requires DIR" >&2; exit 2; }
      TARGET_HOME="$2"
      shift
      ;;
    --profile)
      [[ -n "${2:-}" ]] || { echo "--profile requires a value" >&2; exit 2; }
      DOTFILES_PROFILE="$2"
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "Unknown flag: $1" >&2
      usage >&2
      exit 2
      ;;
  esac
  shift
done

log() { printf '>> %s\n' "$*"; }

assert_safe_path() {
  local path="$1"
  if (( TEST_MODE_ACTIVE )) && [[ "$TEST_OS" == "macos" ]]; then
    case "$path" in
      /etc|/etc/*)
        echo "Refusing to modify $path under DOTFILES_TEST_MODE (macos)" >&2
        exit 98
        ;;
    esac
  fi
}

sanity_checks() {
  local missing=()
  local cmd
  for cmd in "${REQUIRED_COMMANDS[@]}"; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      missing+=("$cmd")
    fi
  done
  if ((${#missing[@]})); then
    printf 'Missing required command(s): %s\n' "${missing[*]}" >&2
    printf 'Install the missing command(s) and re-run bootstrap.\n' >&2
    exit 1
  fi
}

append_unique_line() {
  local file="$1"
  local line="$2"
  assert_safe_path "$file"
  if (( DRY_RUN )); then
    log "[dry-run] append '${line}' -> ${file}"
    return 0
  fi
  mkdir -p "$(dirname "$file")"
  touch "$file"
  grep -qxF "$line" "$file" || printf '%s\n' "$line" >> "$file"
}

ensure_dir() {
  assert_safe_path "$1"
  if (( DRY_RUN )); then
    log "[dry-run] mkdir -p $1"
    return 0
  fi
  mkdir -p "$1"
}

trim_leading_whitespace() {
  local str="$1"
  str="${str#"${str%%[![:space:]]*}"}"
  printf '%s' "$str"
}

backup_conflict_path() {
  local target="$1"
  assert_safe_path "$target"
  if [[ ! -e "$target" && ! -L "$target" ]]; then
    return
  fi
  local suffix=0
  local backup
  while :; do
    backup="${target}.bootstrap-backup"
    if (( suffix > 0 )); then
      backup="${backup}.${suffix}"
    fi
    if [[ ! -e "$backup" && ! -L "$backup" ]]; then
      break
    fi
    ((suffix++))
  done
  assert_safe_path "$backup"
  if (( DRY_RUN )); then
    log "[dry-run] move ${target} -> ${backup} (pre-stow backup)"
    return
  fi
  log "Backing up ${target} -> ${backup} (pre-stow)"
  mkdir -p "$(dirname "$backup")"
  mv "$target" "$backup"
}

detect_os() {
  if [[ "$DETECTED_UNAME" == "Darwin" ]]; then
    echo "macos"
    return
  fi
  if [[ -f /etc/os-release ]]; then
    # shellcheck disable=SC1091
    . /etc/os-release
    if [[ "$ID" == "fedora" || "$ID_LIKE" == *fedora* || "$ID_LIKE" == *rhel* ]]; then
      echo "fedora"
      return
    fi
    if [[ "$ID" == "ubuntu" || "$ID_LIKE" == *debian* ]]; then
      echo "debian"
      return
    fi
  fi
  echo "unknown"
}

detect_brew_bin() {
  if [[ -n "${DOTFILES_BREW_BIN:-}" && -x "${DOTFILES_BREW_BIN}" ]]; then
    printf '%s\n' "${DOTFILES_BREW_BIN}"
    return 0
  fi
  if command -v brew >/dev/null 2>&1; then
    command -v brew
    return 0
  fi
  if (( TEST_MODE_ACTIVE )) && [[ "$TEST_OS" == "macos" ]]; then
    return 1
  fi
  if [[ -x /opt/homebrew/bin/brew ]]; then
    printf '%s\n' "/opt/homebrew/bin/brew"
    return 0
  fi
  if [[ -x /usr/local/bin/brew ]]; then
    printf '%s\n' "/usr/local/bin/brew"
    return 0
  fi
  return 1
}

install_homebrew() {
  if [[ -n "${DOTFILES_BREW_INSTALLER:-}" ]]; then
    if (( DRY_RUN )); then
      log "[dry-run] Invoke custom Homebrew installer: ${DOTFILES_BREW_INSTALLER}"
      return 0
    fi
    "${DOTFILES_BREW_INSTALLER}"
    return
  fi
  if (( DRY_RUN )); then
    log "[dry-run] Install Homebrew via official script"
    return
  fi
  NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
}

ensure_brew_shellenv_line() {
  local brew_bin="$1"
  local dest="${2:-$TARGET_HOME/.zprofile}"
  local line
  line=$(printf 'eval "$(%q shellenv)"' "$brew_bin")
  if (( DRY_RUN )); then
    log "[dry-run] ensure ${dest} exports Homebrew shellenv via ${brew_bin}"
    return
  fi
  assert_safe_path "$dest"
  mkdir -p "$(dirname "$dest")"
  touch "$dest"
  local tmp
  tmp="$(mktemp "${dest}.XXXXXX")"
  awk -v line="$line" '
    /brew shellenv/ {next}
    {print}
    END {print line}
  ' "$dest" > "$tmp"
  mv "$tmp" "$dest"
}

_brew_preflight() {
  local brew_bin="${1:-}"
  [[ -n "$brew_bin" ]] || return 0

  local log_prefix=""
  if (( DRY_RUN )); then
    log_prefix="[dry-run] "
    log "${log_prefix}${brew_bin} update --quiet"
  elif (( TEST_MODE_ACTIVE )); then
    log_prefix="[test] "
    log "${log_prefix}${brew_bin} update --quiet"
    "${brew_bin}" update --quiet >/dev/null 2>&1
  else
    "${brew_bin}" update --quiet >/dev/null 2>&1
  fi

  local tap_list
  tap_list="$("${brew_bin}" tap 2>/dev/null || true)"
  if grep -qx 'homebrew/cask-fonts' <<<"$tap_list"; then
    if (( DRY_RUN )); then
      log "${log_prefix}${brew_bin} untap homebrew/cask-fonts"
      return 0
    fi
    if (( TEST_MODE_ACTIVE )); then
      log "${log_prefix}${brew_bin} untap homebrew/cask-fonts"
    else
      log "Untapping deprecated homebrew/cask-fonts tap"
    fi
    if ! "${brew_bin}" untap homebrew/cask-fonts >/dev/null 2>&1; then
      log "Failed to untap homebrew/cask-fonts (continuing)"
    fi
  fi
}

install_prereqs_macos() {
  local brewfile="${REPO_DIR}/macos/Brewfile"
  if (( DRY_RUN )); then
    log "[dry-run] Verify Xcode Command Line Tools presence"
    if detect_brew_bin >/dev/null 2>&1; then
      local brew_bin
      brew_bin="$(detect_brew_bin)"
      log "[dry-run] Homebrew detected at ${brew_bin}"
      log "[dry-run] ensure ${TARGET_HOME}/.zprofile contains eval for ${brew_bin}"
      log "[dry-run] ${brew_bin} update --quiet"
      log "[dry-run] ${brew_bin} untap homebrew/cask-fonts (if present)"
    else
      log "[dry-run] Install Homebrew via official script"
    fi
    log "[dry-run] brew bundle --file ${brewfile}"
    return
  fi
  if ! xcode-select -p >/dev/null 2>&1; then
    xcode-select --install || true
  fi
  if ! detect_brew_bin >/dev/null 2>&1; then
    install_homebrew
  fi
  local brew_bin
  if ! brew_bin="$(detect_brew_bin)"; then
    echo "Homebrew is required but could not be located after installation." >&2
    exit 1
  fi
  eval "$("$brew_bin" shellenv)"
  ensure_brew_shellenv_line "$brew_bin" "$TARGET_HOME/.zprofile"
  _brew_preflight "$brew_bin"
  brew bundle --file "$brewfile"
}

install_prereqs_debian() {
  if (( DRY_RUN )); then
    log "[dry-run] sudo apt-get update -y"
    log "[dry-run] sudo apt-get install -y (linux/apt-packages.txt)"
    log "[dry-run] Handle fd alternative if needed"
    log "[dry-run] Optional Homebrew on Linux bootstrap"
    return
  fi
  sudo apt-get update -y
  mapfile -t packages < <(grep -vE '^\s*(#|$)' "$REPO_DIR/linux/apt-packages.txt" || true)
  if ((${#packages[@]})); then
    sudo apt-get install -y "${packages[@]}"
  fi
  if ! command -v fd >/dev/null 2>&1 && command -v fdfind >/dev/null 2>&1; then
    sudo update-alternatives --install /usr/local/bin/fd fd "$(command -v fdfind)" 10
  fi
  if ! command -v brew >/dev/null 2>&1; then
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    if [[ -d ~/.linuxbrew ]]; then
      eval "$(~/.linuxbrew/bin/brew shellenv)"
    elif [[ -d /home/linuxbrew/.linuxbrew ]]; then
      eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
    fi
    append_unique_line "$TARGET_HOME/.zshrc" 'eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"'
  fi
}

install_prereqs_fedora() {
  if (( DRY_RUN )); then
    log "[dry-run] sudo dnf makecache"
    log "[dry-run] sudo dnf install -y (linux/dnf-packages.txt)"
    return
  fi
  sudo dnf makecache
  mapfile -t packages < <(grep -vE '^\s*(#|$)' "$REPO_DIR/linux/dnf-packages.txt" || true)
  if ((${#packages[@]})); then
    sudo dnf install -y "${packages[@]}"
  fi
}

install_ohmyzsh() {
  if (( DRY_RUN )); then
    log "[dry-run] Install Oh My Zsh into $HOME/.oh-my-zsh"
    return
  fi
  if [[ ! -d "$HOME/.oh-my-zsh" ]]; then
    RUNZSH=no CHSH=no KEEP_ZSHRC=yes \
      sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
  fi
}

install_powerlevel10k() {
  local theme_dir="${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k"
  if (( DRY_RUN )); then
    log "[dry-run] Ensure powerlevel10k exists at $theme_dir"
    return
  fi
  [[ -d "$theme_dir" ]] || git clone --depth=1 https://github.com/romkatv/powerlevel10k.git "$theme_dir"
}

install_fonts() {
  if (( DRY_RUN )); then
    log "[dry-run] Install Hack & Meslo Nerd fonts (macOS via brew cask, Linux via ~/.local/share/fonts)"
    return
  fi
  echo "Installing Hack Nerd Font (primary) and Meslo Nerd (secondary fallback)..."
  if [[ "$DETECTED_UNAME" == "Darwin" ]]; then
    local brew_bin
    if ! brew_bin="$(detect_brew_bin)"; then
      echo "Homebrew not available; skipping macOS font install." >&2
      return
    fi
    local font
    for font in font-hack-nerd-font font-meslo-lg-nerd-font; do
      if "$brew_bin" list --cask "$font" >/dev/null 2>&1; then
        echo "Font ${font} already installed (via brew)."
      else
        "$brew_bin" install --cask "$font"
      fi
    done
  else
    local font_dir="$HOME/.local/share/fonts"
    mkdir -p "$font_dir"
    curl -fsSL https://github.com/ryanoasis/nerd-fonts/releases/latest/download/Hack.zip -o /tmp/Hack.zip
    unzip -o /tmp/Hack.zip -d "$font_dir" >/dev/null
    curl -fsSL https://github.com/ryanoasis/nerd-fonts/releases/latest/download/Meslo.zip -o /tmp/Meslo.zip
    unzip -o /tmp/Meslo.zip -d "$font_dir" >/dev/null
    fc-cache -fv >/dev/null
  fi
}

install_nvm() {
  if (( DRY_RUN )); then
    log "[dry-run] Install nvm under $HOME/.nvm and ensure LTS default"
    return
  fi
  if [[ ! -d "$HOME/.nvm" ]]; then
    (
      export PROFILE=/dev/null
      curl -fsSL https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
    )
  fi
  # shellcheck disable=SC1090
  [[ -s "$HOME/.nvm/nvm.sh" ]] && . "$HOME/.nvm/nvm.sh"
  nvm install --lts >/dev/null 2>&1 || true
  nvm alias default 'lts/*'
}

install_pyenv() {
  if (( DRY_RUN )); then
    log "[dry-run] Install pyenv under $HOME/.pyenv and set 3.12.6 as global"
    return
  fi
  if ! command -v pyenv >/dev/null 2>&1; then
    curl -fsSL https://pyenv.run | bash
  fi
  export PYENV_ROOT="$HOME/.pyenv"
  export PATH="$PYENV_ROOT/bin:$PATH"
  eval "$(pyenv init -)"
  pyenv install -s 3.12.6
  pyenv global 3.12.6
}

install_rbenv() {
  if (( DRY_RUN )); then
    log "[dry-run] Install rbenv under $HOME/.rbenv and set 3.3.5 as global"
    return
  fi
  if ! command -v rbenv >/dev/null 2>&1; then
    git clone https://github.com/rbenv/rbenv.git "$HOME/.rbenv"
    git clone https://github.com/rbenv/ruby-build.git "$HOME/.rbenv/plugins/ruby-build"
  fi
  export PATH="$HOME/.rbenv/bin:$PATH"
  eval "$(rbenv init -)"
  rbenv install -s 3.3.5
  rbenv global 3.3.5
}

install_tpm() {
  local tpm_dir="$HOME/.tmux/plugins/tpm"
  if (( DRY_RUN )); then
    log "[dry-run] Ensure TPM exists at $tpm_dir"
    return
  fi
  if [[ ! -d "$tpm_dir" ]]; then
    git clone https://github.com/tmux-plugins/tpm "$tpm_dir"
  fi
}

ensure_stow() {
  local os="$1"
  if command -v stow >/dev/null 2>&1; then
    return
  fi
  case "$os" in
    macos)
      if (( DRY_RUN )); then
        log "[dry-run] Ensure GNU Stow via: brew install stow"
        return
      else
        log "Installing GNU Stow via Homebrew"
        brew install stow
      fi
      ;;
    debian)
      if (( DRY_RUN )); then
        log "[dry-run] Ensure GNU Stow via: sudo apt-get install -y stow"
        return
      else
        log "Installing GNU Stow via apt-get"
        sudo apt-get install -y stow
      fi
      ;;
    fedora)
      if (( DRY_RUN )); then
        log "[dry-run] Ensure GNU Stow via: sudo dnf install -y stow"
        return
      else
        log "Installing GNU Stow via dnf"
        sudo dnf install -y stow
      fi
      ;;
    *)
      echo "GNU Stow is required but automatic installation is unsupported for OS: $os" >&2
      exit 1
      ;;
  esac
}

stow_dotfiles() {
  ensure_dir "$HOME"
  if ! command -v stow >/dev/null 2>&1; then
    if (( DRY_RUN )); then
      log "[dry-run] Skip stow linking (GNU Stow not available)"
      return
    fi
    echo "GNU Stow is required but was not installed successfully." >&2
    exit 1
  fi
  pushd "$REPO_DIR/packages" >/dev/null
  for pkg in "${STOW_PKGS[@]}"; do
    if (( DRY_RUN )); then
      log "[dry-run] stow -n --target \"$HOME\" \"$pkg\""
      stow -n --target "$HOME" "$pkg"
    else
      local stow_output
      if stow_output="$(stow -n --target "$HOME" "$pkg" 2>&1)"; then
        stow --target "$HOME" -R "$pkg"
      else
        local cleaned=0
        while IFS= read -r line; do
          if [[ "$line" == *"existing target is not a link:"* || "$line" == *"existing target is neither a link nor a directory:"* ]]; then
            cleaned=1
            local target="${line##*: }"
            target="$(trim_leading_whitespace "$target")"
            target="${target#./}"
            if [[ "$target" != /* ]]; then
              target="$HOME/$target"
            fi
            backup_conflict_path "$target"
          elif [[ "$line" == *"cannot stow"* && "$line" == *"over existing target"* ]]; then
            cleaned=1
            local target_part="${line#*over existing target }"
            target_part="${target_part%% since*}"
            local target="$(trim_leading_whitespace "$target_part")"
            target="${target#./}"
            if [[ "$target" != /* ]]; then
              target="$HOME/$target"
            fi
            backup_conflict_path "$target"
          else
            printf '%s\n' "$line" >&2
          fi
        done <<< "$stow_output"
        if (( cleaned )); then
          stow --target "$HOME" -R "$pkg"
        else
          printf '%s\n' "$stow_output" >&2
          exit 1
        fi
      fi
    fi
  done
  popd >/dev/null
}

select_profile() {
  if [[ -z "${DOTFILES_PROFILE:-}" ]]; then
    echo "Select profile: [1] work  [2] personal"
    read -rp "> " choice
    case "$choice" in
      1) DOTFILES_PROFILE=work ;;
      2) DOTFILES_PROFILE=personal ;;
      *) DOTFILES_PROFILE=personal ;;
    esac
  fi
  export DOTFILES_PROFILE
  local f="$REPO_DIR/profiles/${DOTFILES_PROFILE}/zshrc.profile.zsh"
  if [[ -r "$f" ]]; then
    if (( DRY_RUN )); then
      log "[dry-run] Source profile $f and append loader to $HOME/.zshrc.local"
    else
      if (( TEST_MODE_ACTIVE )); then
        log "[test-mode] Skip sourcing profile $f"
      else
        source "$f"
      fi
      append_unique_line "$HOME/.zshrc.local" "source \"$f\""
    fi
  fi
}

apply_host_overrides() {
  local hn
  hn="$(hostname)"
  local z="$REPO_DIR/hosts/${hn}/zshrc.host.zsh"
  if [[ -r "$z" ]]; then
    if (( DRY_RUN )); then
      log "[dry-run] Source host override $z and append loader to $HOME/.zshrc.local"
    else
      if (( TEST_MODE_ACTIVE )); then
        log "[test-mode] Skip sourcing host override $z"
      else
        source "$z"
      fi
      append_unique_line "$HOME/.zshrc.local" "source \"$z\""
    fi
  fi
  local g="$REPO_DIR/hosts/${hn}/gitconfig.host"
  if [[ -r "$g" ]]; then
    if (( DRY_RUN )); then
      log "[dry-run] Copy $g -> $HOME/.gitconfig.local"
    else
      cp -f "$g" "$HOME/.gitconfig.local"
    fi
  fi
}

main() {
  if [[ ! -d "$REPO_DIR/.git" ]]; then
    if (( DRY_RUN )); then
      log "[dry-run] Clone dotfiles repo into $REPO_DIR"
    else
      ensure_dir "$(dirname "$REPO_DIR")"
      git clone https://github.com/<you>/dotfiles "$REPO_DIR" || true
    fi
  fi

  OS=$(detect_os)
  case "$OS" in
    macos)  install_prereqs_macos ;;
    debian) install_prereqs_debian ;;
    fedora) install_prereqs_fedora ;;
    *) echo "Unsupported OS: $OS" >&2; exit 1 ;;
  esac

  sanity_checks

  local previous_home="$HOME"
  export HOME="$TARGET_HOME"

  install_ohmyzsh
  install_powerlevel10k
  install_fonts
  ensure_stow "$OS"
  stow_dotfiles
  install_tpm
  install_nvm
  install_pyenv
  install_rbenv
  select_profile
  apply_host_overrides

  if [[ "$SHELL" != *zsh ]]; then
    if (( DRY_RUN )); then
      log "[dry-run] chsh -s $(command -v zsh)"
    else
      chsh -s "$(command -v zsh)" || true
    fi
  fi

  export HOME="$previous_home"

  if (( DRY_RUN )); then
    printf "\n✅ Dry run complete. No changes were made.\n"
  else
    printf "\n✅ Done. Open a new terminal.\n"
    echo "Set your terminal font to 'Hack Nerd Font' (primary) or 'MesloLGS Nerd Font' (fallback)."
    echo "Run 'tmux' then prefix + I to install tmux plugins."
    echo "Optionally run: ~/.dotfiles/bin/keys-setup"
  fi
}

if [[ -z "${BASH_SOURCE[0]:-}" || "${BASH_SOURCE[0]}" == "$0" ]]; then
  main "$@"
fi
